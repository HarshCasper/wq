# How To: Configure IDs and Labels

wq's built-in [model registration][router] system makes it possible to quickly scaffold an application with default list/edit/detail views for each model.  However, it is almost always necessary to override the generated label for each record in the database.  Additionally, it is often desirable to override the identifier used to specify each record, for example to create friendly slug-based urls.

These two options are configured somewhat differently in wq, but since they are so closely related it makes sense to discuss both in this guide.

 1. [Record Labels](#record-labels)
 2. [Record IDs](#record-ids)
 
> Note that it is also possible to configure the [verbose names][configure-route-names-and-urls] used to describe each model as a whole, for example in the title of list views.   This guide focuses only on record-level identifiers - see [How To: Configure Route Names and URLs][configure-route-names-and-urls] for collection-level configuration.

## Record Labels

Suppose you have a model named `Group` that is [registered with wq.db][router].

```python
# myapp/models.py
class Group(models.Model):
    name = models.TextField()

# myapp/rest.py
from wq.db import rest
from .models import Group

rest.router.register_model(
    Group,
    name = models.TextField()
)
```

As you start populating this model with data, you may notice that the records have generic names like "Group Object (1)" and "Group Object (2)".  To fix this, you can use Django's built-in [__str__() support][django:__str__] to give each record a label:

```python
class Group(models.Model):
    name = models.TextField()
    def __str__(self):
        return self.name
```

This will work fine as long as each record is synced to the server instantly so it can return the label.  However, if you plan to be offline for extended periods of time you will also want to configure offline labels.

### Offline Record Labels

Record labels can be generated offline by setting `wq_label_template` on the model.  (This setting would ideally go on the `Meta` class, but it's not a standard Django attribute.)

```python
class Group(models.Model):
    name = models.TextField()
    wq_label_template = '{{name}}'
    def __str__(self):
        return self.name
```

To reduce redundancy, you can import `LabelModel` which already implements `__str__()` to render the contents of `wq_label_template`:

```python
from wq.db.patterns.models import LabelModel

class Group(LabelModel):
    name = models.TextField()
    wq_label_template = '{{name}}'
```

LabelModel's default template is `"{{name}}"`, so you could even leave out wq_label_template in this specific case.

### Advanced Offline Record Labels

If a Mustache template is not sufficient, you can also implement the offline template as a JavaScript function.  Since the `data/config.js` generated by wq.db is effectively JSON-only, a JavaScript template should be defined elsewhere in the application code.

```hs
// app/js/myproject.js (or app/src/config.js)
import wq from './wq.js';
import config from './data/config.js';

config.pages.group.label_template = group => group.name;

wq.init(config);
```

## Record IDs

By default, wq.db will use Django's automatic id AutoField as the record identifier in URL lookups and in JSON sent to the client.  In many use cases it is desirable to use a different value.  The default field can be overridden directly in the model definition, by explicitly defining a field with `primary_key=True`.  However, the recommended approach is to define a second unique field on the model and register it with wq.db as the "lookup" field.

```python
# myapp/models.py

class Group(LabelModel):
    code = models.SlugField(unique=True)
    name = models.TextField()

# myapp/rest.py
from wq.db import rest
from .models import Group

rest.router.register_model(
    Group,
    lookup="code",
    fields="__all__"
)
```

The lookup value is always mapped to "id" in the JSON output, so wq.app (and specifically the [ORM][@wq/model]) can treat it as the primary key.  While this could also be accomplished with a custom [ModelSerializer] class, doing it via `register_model()` also ensures that the corresponding `ModelViewSet` can handle detail URLs using the same identifier.  In addition, the `lookup` setting is automatically propagated to the serialization of any foreign keys in related models.

### Offline Record IDs - Not Needed

One common use for custom id fields is to facilitate offline usage, since it is not possible to know what identifier the server will assign until the record is synced.  (In other projects, this use case is commonly handled by using a UUID field.)  **wq automatically generates offline record ids**, regardless of the `lookup` setting or any custom primary key on the model.  The offline IDs are automatically swapped for the actual `"id"` value returned from the server during sync.  If there are any related models, they will not be synced until the parent model has its server-assigned identifier.

Thus, it is not necessary to define a template or function to generate offline record identifiers.
